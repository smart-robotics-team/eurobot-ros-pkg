// ROS message includes
#include "ros/ros.h"
#include <sensor_msgs/PointCloud2.h>

/* protected region user include files on begin */
#include <tf/transform_listener.h>
#include <tf/transform_broadcaster.h>
#include <laser_geometry/laser_geometry.h>

#include <pcl/point_types.h>
#include <pcl/io/io.h>
#include <pcl/io/pcd_io.h>
#include <pcl/filters/passthrough.h>
#include <pcl_conversions/pcl_conversions.h>
#include <pcl_ros/transforms.h>

#include <sys/time.h>
#include <sys/types.h>
#include <unistd.h>

#include <stdio.h>                                         // for in-/output
#include <string.h>                                        // strcat

//Include system headers
#include <cstring>
#include <iostream>
#include <cstdio>

#include <sstream>
#include <math.h>
#include <vector>

#define STATE_1         0
#define STATE_2         1
#define STATE_3         2
#define STATE_4         3
#define STATE_5         4

/* protected region user include files end */

class beacon_pose_init_config
{
	public:
		double x_object1;
		double y_object1;
		double x_object2;
		double y_object2;
		double x_init_pose;
		double y_init_pose;
		std::string base_beacon_link;
		std::string laser_beacon_link;
};

class beacon_pose_init_data
{
	// autogenerated: don't touch this class
	public:
		//input data
		sensor_msgs::PointCloud2 in_input;
		//output data
};

class beacon_pose_init_impl
{
	/* protected region user member variables on begin */
	beacon_pose_init_config localconfig;

	tf::StampedTransform t;
	tf::TransformBroadcaster broadcaster;

	double x, y, yaw;
	double side;

	int state;
	int cpt;

	bool variable_configured;
	/* protected region user member variables end */

	public:
	beacon_pose_init_impl() 
	{
		/* protected region user constructor on begin */
		side = -1.0;


		state = STATE_1;
		cpt = 0;

		variable_configured = false;
		/* protected region user constructor end */
	}

	void configure(beacon_pose_init_config config) 
	{
		/* protected region user configure on begin */
		localconfig = config;
		if(!variable_configured)
		{
			x = localconfig.x_init_pose;
			y = localconfig.y_init_pose;
			yaw = 0.0;
			variable_configured = true;
		}
		/* protected region user configure end */
	}

	void update(beacon_pose_init_data &data, beacon_pose_init_config config)
	{
		/* protected region user update on begin */
		if(variable_configured)
		{
			t = tf::StampedTransform(tf::Transform(tf::createQuaternionFromYaw(yaw), tf::Vector3(x, y, 0.0)),
					ros::Time::now(), localconfig.base_beacon_link, localconfig.laser_beacon_link);

			t.stamp_ = ros::Time::now();
			broadcaster.sendTransform(t);

		}
		/* protected region user update end */
	}

	void topicCallback_input(const sensor_msgs::PointCloud2::ConstPtr& msg)
	{
		/* protected region user implementation of subscribe callback for input on begin */
		if(variable_configured)
		{
			pcl::PCLPointCloud2::Ptr pcl_pc(new pcl::PCLPointCloud2 ());
			pcl::PointCloud<pcl::PointXYZ>::Ptr pcl_cloud (new pcl::PointCloud<pcl::PointXYZ>);
			pcl::PointCloud<pcl::PointXYZ>::Ptr final (new pcl::PointCloud<pcl::PointXYZ>);
			pcl::PointCloud<pcl::PointXYZ>::Ptr final2 (new pcl::PointCloud<pcl::PointXYZ>);
			pcl::PCLPointCloud2::Ptr cloud_out (new pcl::PCLPointCloud2 ());
			sensor_msgs::PointCloud2 pc2;
			std::vector<int> inliers;


			// Transformation into PCL type PointCloud2
			pcl_conversions::toPCL((*msg), *(pcl_pc));

			// Transformation into PCL type PointCloud<pcl::PointXYZRGB>
			pcl::fromPCLPointCloud2(*(pcl_pc), *(pcl_cloud));


			////////////////////////
			// PassThrough filter //
			////////////////////////
			pcl::PassThrough<pcl::PointXYZ> pass;
			pass.setInputCloud (pcl_cloud);
			pass.setFilterFieldName ("x");
			pass.setFilterLimits (localconfig.x_object1-0.05, localconfig.x_object1+0.05);
			//pass.setFilterLimitsNegative (true);
			pass.filter (*final);

			pass.setInputCloud (final);
			pass.setFilterFieldName ("y");
			pass.setFilterLimits (localconfig.y_object1-0.05, localconfig.y_object1+0.05);
			//pass.setFilterLimitsNegative (true);
			pass.filter (*final);

			////////////////////////
			// PassThrough filter //
			////////////////////////
			pass.setInputCloud (pcl_cloud);
			pass.setFilterFieldName ("x");
			pass.setFilterLimits (localconfig.x_object2-0.05, localconfig.x_object2+0.05);
			//pass.setFilterLimitsNegative (true);
			pass.filter (*final2);

			pass.setInputCloud (final2);
			pass.setFilterFieldName ("y");
			pass.setFilterLimits (localconfig.y_object2-0.05, localconfig.y_object2+0.05);
			//pass.setFilterLimitsNegative (true);
			pass.filter (*final2);


			double mean = 0.0;
			double mean2 = 0.0;
			int i = 0;

			switch(state) {
				case STATE_1 :
					// Check if X is equal between both clusters : change YAW

					if(final->size() > 0)
					{
						for(i = 0; i < final->size(); i++)
						{
							mean += final->at(i).x;
						}
						mean = mean / final->size();


						if(final2->size() > 0)
						{
							for(i = 0; i < final2->size(); i++)
							{
								mean2 += final2->at(i).x;
							}
							mean2 = mean2 / final2->size();

							yaw += (mean2 - mean)/10;
							cpt++;

						}
						else {

						}

					}
					else
					{
						// DO nothing
					}


					if(cpt > 40)
					{
						cpt = 0;
						state = STATE_2;
					}



					break;
				case STATE_2 :
					// Check if Y are at a correct position : change Y

					if(final->size() > 0)
					{
						for(i = 0; i < final->size(); i++)
						{
							mean += final->at(i).y;
						}
						mean = mean / final->size();


						if(final2->size() > 0)
						{
							for(i = 0; i < final2->size(); i++)
							{
								mean2 += final2->at(i).y;
							}
							mean2 = mean2 / final2->size();

							y += -(0.05 - mean)/4;
							cpt++;

						}
						else {

						}

					}
					else
					{
						// DO nothing
					}


					if(cpt > 40)
					{
						cpt = 0;
						state = STATE_3;
					}


					break;
				case STATE_3 :
					// Check if X are at a correct position : change X

					//-1.4 // 0.0
					if(final->size() > 0)
					{
						for(i = 0;i < final->size(); i++)
						{
							mean += final->at(i).x;
						}
						mean = mean / final->size();

						x += -(side*1.45 - mean)/4;
						cpt++;
					}
					else
					{
						// DO nothing
					}

					if(cpt > 40)
					{
						cpt = 0;
						state = STATE_4;
					}


					break;
				case STATE_4 :
					// Done

					break;
				default :

					break;
			}




		}
		/* protected region user implementation of subscribe callback for input end */
	}



	/* protected region user additional functions on begin */
	/* protected region user additional functions end */
};
